# ES5的继承怎么实现？

ES5 中实现继承的几种常见方式包括原型链继承、构造函数继承、组合继承、原型式继承和寄生组合继承。下面我会简要介绍一下这些方式的实现原理和示例代码。

1. **原型链继承：**
   原型链继承是通过将子类的原型对象指向父类的实例来实现继承。但是这种方式有一个缺点，就是子类实例会共享父类实例的属性，存在属性共享和无法传递参数的问题。
   ```javascript
   function Parent() {
     this.name = 'Parent';
   }

   Parent.prototype.sayHello = function() {
     console.log('Hello from ' + this.name);
   };

   function Child() {}

   Child.prototype = new Parent(); // 原型链继承

   var child = new Child();
   child.sayHello(); // 输出："Hello from Parent"
   ```

2. **构造函数继承：**
   构造函数继承是通过在子类构造函数中调用父类构造函数来实现继承，从而解决了原型链继承的属性共享问题。但是这种方式无法继承父类原型链上的方法。
   ```javascript
   function Parent(name) {
     this.name = name || 'Parent';
   }

   function Child() {
     Parent.call(this, 'Child');
   }

   var child = new Child();
   console.log(child.name); // 输出："Child"
   ```

3. **组合继承：**
   组合继承结合了原型链继承和构造函数继承的优点，既可以继承父类原型上的方法，又可以避免属性共享的问题。
   ```javascript
   function Parent(name) {
     this.name = name || 'Parent';
   }

   Parent.prototype.sayHello = function() {
     console.log('Hello from ' + this.name);
   };

   function Child(name) {
     Parent.call(this, name);
   }

   Child.prototype = new Parent(); // 组合继承

   var child = new Child('Child');
   child.sayHello(); // 输出："Hello from Child"
   ```

4. **原型式继承：**
   原型式继承是通过创建一个空的构造函数，并将其原型对象指向一个已有的对象来实现继承。
   ```javascript
   function object(o) {
     function F() {}
     F.prototype = o;
     return new F();
   }

   var parent = {
     name: 'Parent',
     sayHello: function() {
       console.log('Hello from ' + this.name);
     }
   };

   var child = object(parent);
   child.name = 'Child';
   child.sayHello(); // 输出："Hello from Child"
   ```

5. **寄生组合继承：**
   寄生组合继承是在组合继承的基础上做进一步优化，避免了多次调用父类构造函数和共享原型对象。
   ```javascript
   function inheritPrototype(Child, Parent) {
     var prototype = Object.create(Parent.prototype);
     prototype.constructor = Child;
     Child.prototype = prototype;
   }

   function Parent(name) {
     this.name = name || 'Parent';
   }

   Parent.prototype.sayHello = function() {
     console.log('Hello from ' + this.name);
   };

   function Child(name) {
     Parent.call(this, name);
   }

   inheritPrototype(Child, Parent); // 寄生组合继承

   var child = new Child('Child');
   child.sayHello(); // 输出："Hello from Child"
   ```

这些继承方式各有优缺点，开发者可以根据具体情况选择合适的方式来实现继承。在实际应用中，一般推荐使用组合继承或者寄生组合继承，它们既继承了父类的属性和方法，又避免了属性共享和无效的构造函数调用。