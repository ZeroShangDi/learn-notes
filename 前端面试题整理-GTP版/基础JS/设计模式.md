# 设计模式

设计模式是在软件开发中常用的一种解决方案，它提供了一套被认可的最佳实践，可以帮助开发者更高效地编写可维护、可扩展和可复用的代码。设计模式分为三大类：创建型模式、结构型模式和行为型模式。下面我将以JavaScript语言介绍常见的设计模式，并列出它们的名称、意义、代码实现和常用场景。

### 创建型模式

#### 1. 工厂模式（Factory Pattern）
- **意义：** 通过工厂方法创建对象，隐藏了对象的创建细节，降低了对象之间的耦合度。
- **代码实现：**
  ```javascript
  class Car {
    constructor(model, year) {
      this.model = model;
      this.year = year;
    }
  }

  class CarFactory {
    createCar(model, year) {
      return new Car(model, year);
    }
  }

  const factory = new CarFactory();
  const myCar = factory.createCar('Toyota', 2022);
  console.log(myCar);
  ```
- **常用场景：** 创建对象时需要根据条件返回不同类型的对象。

#### 2. 单例模式（Singleton Pattern）
- **意义：** 确保一个类只有一个实例，并提供一个全局访问点。
- **代码实现：**
  ```javascript
  class Singleton {
    constructor() {
      if (!Singleton.instance) {
        Singleton.instance = this;
      }
      return Singleton.instance;
    }
  }

  const instance1 = new Singleton();
  const instance2 = new Singleton();
  console.log(instance1 === instance2); // true
  ```
- **常用场景：** 需要保证系统中某个类只有一个实例，例如全局配置对象、日志对象等。

#### 3. 原型模式（Prototype Pattern）
- **意义：** 原型模式通过复制现有对象来创建新对象，而不是通过实例化类。这种模式适用于需要创建大量相似对象的情况，可以节省对象创建的开销。
- **代码实现：**
  ```javascript
  class Car {
    constructor(model, year) {
      this.model = model;
      this.year = year;
    }

    clone() {
      return new Car(this.model, this.year);
    }
  }

  const car1 = new Car('Toyota', 2022);
  const car2 = car1.clone();
  console.log(car2); // Car { model: 'Toyota', year: 2022 }
  ```
- **常用场景：** 当需要创建大量相似对象时，可以使用原型模式来复制现有对象而不是每次都实例化新对象。


### 结构型模式

#### 1. 适配器模式（Adapter Pattern）
- **意义：** 将一个类的接口转换成客户端所期待的另一个接口。
- **代码实现：**
  ```javascript
  class OldCalculator {
    constructor() {
      this.operations = function (a, b, operation) {
        switch (operation) {
          case 'add':
            return a + b;
          case 'subtract':
            return a - b;
          default:
            return NaN;
        }
      };
    }
  }

  class NewCalculator {
    add(a, b) {
      return a + b;
    }

    subtract(a, b) {
      return a - b;
    }
  }

  class Adapter {
    constructor() {
      const newCalc = new NewCalculator();

      this.operations = function (a, b, operation) {
        switch (operation) {
          case 'add':
            return newCalc.add(a, b);
          case 'subtract':
            return newCalc.subtract(a, b);
          default:
            return NaN;
        }
      };
    }
  }

  const calcAdapter = new Adapter();
  console.log(calcAdapter.operations(5, 3, 'add')); // 8
  ```
- **常用场景：** 当需要使用已有的类，但是其接口与需求不匹配时，可以通过适配器模式进行接口转换。

#### 2. 装饰者模式（Decorator Pattern）
- **意义：** 动态地给对象添加额外的职责，是继承的一个替代方案。
- **代码实现：**
  ```javascript
  class Coffee {
    cost() {
      return 10;
    }
  }

  class MilkDecorator {
    constructor(coffee) {
      this.coffee = coffee;
    }

    cost() {
      return this.coffee.cost() + 5;
    }
  }

  class SugarDecorator {
    constructor(coffee) {
      this.coffee = coffee;
    }

    cost() {
      return this.coffee.cost() + 3;
    }
  }

  let myCoffee = new Coffee();
  myCoffee = new MilkDecorator(myCoffee);
  myCoffee = new SugarDecorator(myCoffee);

  console.log(myCoffee.cost()); // 18
  ```
- **常用场景：** 在不修改对象自身的基础上，动态地给对象添加功能。

#### 3. 桥接模式（Bridge Pattern）
- **意义：** 桥接模式用于将抽象部分与实现部分分离，使它们可以独立变化。它通过将抽象与实现解耦来提高灵活性。
- **应用场景：** 当需要支持多种不同的平台或者多种不同的设备时，可以使用桥接模式将抽象部分（如功能）与实现部分（如平台或设备）分开管理。

#### 4. 组合模式（Composite Pattern）
- **意义：** 组合模式用于将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
- **应用场景：** 在处理树形结构数据时，可以使用组合模式来统一处理叶子节点和组合节点，例如文件系统中的文件和文件夹的关系。

#### 5. 外观模式（Facade Pattern）
- **意义：** 外观模式提供了一个高层接口，使得系统中的一组接口更易于使用。它隐藏了系统复杂性，提供了一个简单的接口给客户端。
- **应用场景：** 在处理复杂系统或者一系列相互依赖的子系统时，可以使用外观模式来简化客户端与子系统之间的交互，提高系统的易用性。

这些结构型模式都有各自独特的特点和应用场景，可以根据具体的需求选择合适的模式来提高代码的可维护性、可扩展性和复用性。

下面我们来逐个介绍命令模式、模板模式、状态模式、迭代器模式、职责链模式、解析器模式、备忘录模式和访问者模式，以及它们在软件设计中的意义和应用场景。

#### 6. 享元模式（Flyweight Pattern）
- **意义：** 享元模式旨在通过共享对象来最小化内存使用和提高性能。它适用于大量相似对象的情况，通过共享公共部分减少内存占用。
- **应用场景：** 例如在图形编辑器中，可以使用享元模式来共享相同的形状对象，从而节省内存空间。

#### 7. 代理模式（Proxy Pattern）
- **意义：** 代理模式在访问对象时引入了一定程度的间接性，可以用于控制对目标对象的访问，例如限制对某些敏感方法的调用或延迟加载目标对象。
- **代码实现：**
  ```javascript
  class RealImage {
    constructor(fileName) {
      this.fileName = fileName;
      this.loadImage();
    }

    loadImage() {
      console.log(`Loading image: ${this.fileName}`);
    }

    displayImage() {
      console.log(`Displaying image: ${this.fileName}`);
    }
  }

  class ProxyImage {
    constructor(fileName) {
      this.fileName = fileName;
      this.image = null;
    }

    displayImage() {
      if (!this.image) {
        this.image = new RealImage(this.fileName);
      }
      this.image.displayImage();
    }
  }

  const proxyImage = new ProxyImage('example.jpg');
  proxyImage.displayImage(); // Output: Loading image: example.jpg, Displaying image: example.jpg
  proxyImage.displayImage(); // Output: Displaying image: example.jpg
  ```
- **常用场景：** 在访问某些资源或对象时需要控制访问的方式，例如延迟加载、访问权限控制等情况下可以使用代理模式。

这些设计模式虽然在 JavaScript 中不太常用，但在特定的场景下仍然能够提供有用的解决方案。


当谈及设计模式时，享元模式、桥接模式、组合模式和外观模式是结构型模式中的一部分，它们分别解决了不同的问题和应用场景。




### 行为型模式

#### 1. 观察者模式（Observer Pattern）
- **意义：** 定义对象间的一对多依赖关系，当一个对象的状态发生改变时，其相关依赖对象会收到通知并自动更新。
- **代码实现：**
  ```javascript
  class Subject {
    constructor() {
      this.observers = [];
    }

    addObserver(observer) {
      this.observers.push(observer);
    }

    notifyObservers(message) {
      this.observers.forEach(observer => observer.update(message));
    }
  }

  class Observer {
    update(message) {
      console.log(`Received message: ${message}`);
    }
  }

  const subject = new Subject();
  const observer1 = new Observer();
  const observer2 = new Observer();

  subject.addObserver(observer1);
  subject.addObserver(observer2);

  subject.notifyObservers('Hello observers!');
  ```
- **常用场景：** 当一个对象的改变需要通知其他对象，并且不希望这些对象紧密耦合时，可以使用观察者模式。

#### 2. 访问者模式（Visitor Pattern）

#### 3. 中介者模式（Mediator Pattern）

#### 4. 策略模式（Strategy Pattern）
- **意义：** 定义一系列算法，将每个算法封装起来，并使它们可以相互替换，使得算法的变化不会影响使用算法的客户。
- **代码实现：**
  ```javascript
  class PaymentStrategy {
    pay(amount) {
      throw new Error('This method must be overridden!');
    }
  }

  class CreditCardStrategy extends PaymentStrategy {
    pay(amount) {
      console.log(`Paying ${amount} using credit card.`);
    }
  }

  class PayPalStrategy extends PaymentStrategy {
    pay(amount) {
      console.log(`Paying ${amount} using PayPal.`);
    }
  }

  const paymentContext = (strategy, amount) => {
    strategy.pay(amount);
  };

  const creditCardStrategy = new CreditCardStrategy();
  const payPalStrategy = new PayPalStrategy();

  paymentContext(creditCardStrategy, 100);
  paymentContext(payPalStrategy, 50);
  ```
- **常用场景：** 当需要在运行时根据不同的情况选择算法时，可以使用策略模式。

当谈及 JavaScript 中不太常用但仍然有价值的设计模式时，以下两种模式可能不太常见，但在特定场景下仍然具有一定的意义。







#### 5. 命令模式（Command Pattern）
- **意义：** 命令模式将请求封装成对象，使得可以将请求参数化、队列化、记录日志、撤销等操作，同时降低发送者和接收者之间的耦合度。
- **应用场景：** 在需要实现命令的撤销、重做或者日志记录的情况下，可以使用命令模式。

#### 6. 模板模式（Template Pattern）
- **意义：** 模板模式定义一个算法的骨架，将算法中不变的部分封装在父类中，而将可变的部分交给子类来实现。它使得子类可以不改变算法结构而重新定义算法的某些步骤。
- **应用场景：** 在需要实现某个算法的多个变种时，可以使用模板模式来避免代码重复。

#### 7. 状态模式（State Pattern）
- **意义：** 状态模式允许对象在内部状态改变时改变其行为，使得对象看起来好像修改了其类。它将不同的状态封装成独立的类，并且可以动态切换状态。
- **应用场景：** 在对象的行为取决于其状态，并且需要在状态改变时改变行为的情况下，可以使用状态模式。

#### 8. 迭代器模式（Iterator Pattern）
- **意义：** 迭代器模式提供一种访问对象元素的方式，而无需暴露对象的内部表示。它通过提供统一的接口来遍历集合对象中的元素。
- **应用场景：** 在需要遍历不同类型集合（如数组、链表、树等）中的元素并统一对待的情况下，可以使用迭代器模式。

#### 9. 职责链模式（Chain of Responsibility Pattern）
- **意义：** 职责链模式通过将请求传递给多个处理对象来处理请求，直到其中一个处理对象能够处理该请求为止。它降低了发送者和接收者之间的耦合度。
- **应用场景：** 在需要根据请求的类型动态决定处理请求的对象，并且可能存在多个处理对象处理请求的情况下，可以使用职责链模式。

#### 10. 解析器模式（Interpreter Pattern）
- **意义：** 解析器模式用于定义语言的文法，并解释语言中的表达式。它将文法表示成一个类的层次结构，每个类表示一个语法规则，并提供解释方法来解释表达式。
- **应用场景：** 在需要解析和执行特定语言或者规则的文法表达式时，可以使用解析器模式。

#### 11. 备忘录模式（Memento Pattern）
- **意义：** 备忘录模式用于捕获对象的内部状态并在需要时恢复该状态。它将对象的状态保存到备忘录对象中，可以随时恢复到之前的状态。
- **应用场景：** 在需要保存和恢复对象状态的情况下，可以使用备忘录模式，例如撤销操作功能。


- **意义：** 访问者模式用于定义对象间的新操作，而无需改变对象本身的类。它通过在访问者对象中定义操作，并在被访问对象中提供接收操作的方法来实现。
- **应用场景：** 在需要对一个对象结构中的元素进行多种不同操作，并且操作可能会发生变化的情况下，可以使用访问者模式。

这些设计模式在软件设计中都有各自的用途和优势，可以根据具体的需求和场景选择合适的模式来提高代码的可维护性、可扩展性和复用性。