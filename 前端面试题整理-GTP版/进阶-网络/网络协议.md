# http有哪些方法？

HTTP（超文本传输协议）定义了一组方法，用于在客户端和服务器之间传输数据。以下是 HTTP 常见的方法及其用途：

1. **GET**：
   - 用于请求指定资源的信息。
   - 请求数据包含在 URL 中。
   - 通常用于获取数据。
   - 不应对服务器上的资源产生任何副作用（幂等的）。

   ```http
   GET /resource HTTP/1.1
   Host: example.com
   ```

2. **POST**：
   - 用于向服务器提交数据。
   - 数据包含在请求体中。
   - 通常用于创建新的资源或提交表单数据。
   - 可能会对服务器上的资源产生副作用。

   ```http
   POST /resource HTTP/1.1
   Host: example.com
   Content-Type: application/json

   {
     "name": "Alice",
     "age": 30
   }
   ```

3. **PUT**：
   - 用于更新指定资源的数据。
   - 数据包含在请求体中。
   - 如果资源不存在，可能会创建新的资源（取决于服务器实现）。
   - 幂等的，即相同的请求执行多次，结果是相同的。

   ```http
   PUT /resource/1 HTTP/1.1
   Host: example.com
   Content-Type: application/json

   {
     "name": "Alice",
     "age": 31
   }
   ```

4. **DELETE**：
   - 用于删除指定的资源。
   - 幂等的，即相同的请求执行多次，结果是相同的。

   ```http
   DELETE /resource/1 HTTP/1.1
   Host: example.com
   ```

5. **HEAD**：
   - 类似于 GET 请求，但只返回响应的头部，不包含响应体。
   - 通常用于检查资源是否存在以及获取资源的元数据。

   ```http
   HEAD /resource HTTP/1.1
   Host: example.com
   ```

6. **OPTIONS**：
   - 用于描述指定资源的通信选项。
   - 通常用于检查服务器支持哪些 HTTP 方法。

   ```http
   OPTIONS /resource HTTP/1.1
   Host: example.com
   ```

7. **PATCH**：
   - 用于对资源进行部分修改。
   - 数据包含在请求体中。
   - 不是幂等的，但通常需要实现幂等。

   ```http
   PATCH /resource/1 HTTP/1.1
   Host: example.com
   Content-Type: application/json

   {
     "age": 32
   }
   ```

8. **TRACE**：
   - 用于执行一个消息环回测试，沿路径发送到目标资源的请求将被环回回来。
   - 通常用于诊断。

   ```http
   TRACE /resource HTTP/1.1
   Host: example.com
   ```

9. **CONNECT**：
   - 用于将请求连接转换为透明的 TCP/IP 隧道。
   - 通常用于 HTTPS 连接通过代理服务器的场景。

   ```http
   CONNECT www.example.com:443 HTTP/1.1
   Host: www.example.com
   ```

### 常见用途示例

- **GET** 请求用于读取数据，例如加载网页内容或检索信息。
- **POST** 请求用于提交表单数据或创建新资源。
- **PUT** 请求用于更新现有资源或创建资源。
- **DELETE** 请求用于删除资源。
- **HEAD** 请求用于检查资源是否存在而不获取资源内容。
- **OPTIONS** 请求用于获取服务器支持的 HTTP 方法和功能。
- **PATCH** 请求用于部分更新资源。

了解这些 HTTP 方法及其用途，有助于更好地设计和实现 RESTful API 和 Web 应用程序。

# HTTP和HTTPS的区别

HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是两种常见的网络传输协议，它们之间主要区别在于安全性和加密方式。

1. **安全性：**
   - **HTTP：** HTTP 是一种不安全的传输协议，数据在传输过程中是明文传输的，容易被中间人攻击、窃听和篡改。
   - **HTTPS：** HTTPS 则是在 HTTP 的基础上加入了 SSL/TLS 加密层，通过使用 SSL/TLS 协议对数据进行加密和认证，保证数据在传输过程中的安全性，防止被窃听、篡改和劫持。

2. **加密方式：**
   - **HTTP：** HTTP 不使用加密，数据以明文方式传输。
   - **HTTPS：** HTTPS 使用 SSL/TLS 协议对数据进行加密，通过对称加密、非对称加密和数字签名等技术保证数据的完整性和安全性。

3. **端口号：**
   - **HTTP：** HTTP 默认使用端口号 80 进行通信。
   - **HTTPS：** HTTPS 默认使用端口号 443 进行通信。

4. **证书：**
   - **HTTP：** 不需要证书，是一种无需认证的传输方式。
   - **HTTPS：** 需要使用 SSL/TLS 数字证书来进行身份认证和加密通信，证书由权威的证书颁发机构（CA，Certificate Authority）颁发，用于验证服务器身份和加密通信。

5. **使用场景：**
   - **HTTP：** 适用于对安全性要求不高的场景，如浏览普通网页、下载一般资源等。
   - **HTTPS：** 适用于对安全性要求较高的场景，如网银交易、登录注册、在线支付等涉及敏感信息的场景。

总体来说，HTTPS 是对 HTTP 的加强和安全改进，通过加密数据传输、身份认证和数字签名等机制，保证了数据在传输过程中的安全性和完整性。因此，在处理涉及用户隐私和敏感信息的场景下，推荐使用 HTTPS 协议来保证数据的安全传输。

# HTTPS一定安全嘛，在什么情况下不安全

虽然HTTPS协议相比HTTP协议更安全，但并不是绝对安全的。在某些情况下，HTTPS也可能存在安全问题，以下是一些可能导致HTTPS不安全的情况：

1. **证书信任链被破坏：** 如果HTTPS连接使用的是伪造的或不受信任的数字证书，浏览器无法验证服务器的身份，导致中间人攻击（Man-in-the-Middle Attack）。

2. **弱密码或未更新的加密算法：** 如果使用弱密码或已知的加密算法（如DES、RC4等）进行加密通信，可能被攻击者破解，造成数据泄露或篡改。

3. **恶意脚本注入：** 在HTTPS连接中，如果网站存在恶意脚本注入或XSS（跨站脚本攻击）漏洞，攻击者可以利用这些漏洞来窃取用户的敏感信息。

4. **中间人攻击：** 尽管HTTPS能够防止中间人攻击，但如果攻击者能够获取到服务器的私钥或者在用户计算机中安装恶意的根证书，就有可能进行中间人攻击，篡改数据或窃取信息。

5. **客户端环境受到攻击：** 如果用户的计算机或移动设备受到恶意软件、病毒或钓鱼攻击，攻击者可能通过这些途径来获取HTTPS连接中的敏感信息。

6. **SSL/TLS漏洞：** 如果SSL/TLS协议本身存在安全漏洞或者使用了已知的弱加密算法，可能导致攻击者通过这些漏洞来破解加密通信。

7. **不安全的第三方内容：** 如果网站使用了不安全的第三方内容（如图片、脚本、样式表等），可能会因为这些内容的不安全性而影响整个网站的安全性。

因此，在使用HTTPS协议时，需要注意以下几点来提高安全性：

- 使用受信任的SSL/TLS证书，并定期更新证书。
- 配置服务器安全设置，禁止不安全的加密算法和协议。
- 避免使用不受信任的第三方内容。
- 定期更新服务器和客户端的安全补丁，保持系统和软件的安全性。
- 对网站进行安全审计和漏洞扫描，及时修复发现的安全漏洞。


# Get和Post的区别

GET和POST是HTTP协议中两种常用的请求方法，它们在用途、数据传输方式和安全性等方面有一些区别。

1. **用途**：
   - GET：用于从服务器获取资源，通常用于请求数据，比如获取网页、图片、文本文件等。
   - POST：用于向服务器提交数据，通常用于提交表单数据、上传文件、发送JSON数据等。

2. **数据传输方式**：
   - GET：通过URL参数传输数据，数据会附在URL的末尾，以键值对的形式出现（如`?key1=value1&key2=value2`）。
   - POST：通过请求体（Request Body）传输数据，数据不会暴露在URL中，而是在请求的头部中包含了数据的长度和类型。

3. **数据大小限制**：
   - GET：由于数据是附在URL中的，所以对数据的大小有限制，一般在几 KB 到几 MB 之间，具体限制取决于浏览器和服务器的设置。
   - POST：由于数据是通过请求体传输的，所以理论上可以传输大量的数据，但是同样受到服务器和客户端的限制。

4. **安全性**：
   - GET：因为数据暴露在URL中，所以不适合传输敏感信息，如密码等，因为这些信息可能会被记录在日志、浏览器历史或者网络传输过程中的中间节点。
   - POST：相比GET请求，POST请求更安全，因为数据不会暴露在URL中，而是在请求体中传输，所以适合传输敏感信息。

5. **缓存机制**：
   - GET：请求会被浏览器缓存，因此会被缓存下来，下次再请求同一个URL时，浏览器会直接从缓存中获取数据，而不会再向服务器发起请求。
   - POST：请求不会被浏览器缓存，每次请求都会向服务器发起新的请求。

6. **GET⽆害**： 
   - 刷新、后退等浏览器操作GET请求是⽆害的，POST可能重复提交表单 
   
7. **特性不同**：
   - GET是安全（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化）且幂等（幂等的 概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同），⽽POST是⾮安全⾮幂等

综上所述，GET和POST在用途、数据传输方式、数据大小限制、安全性和缓存机制等方面有所不同，开发者需要根据具体的需求来选择合适的请求方法。例如，需要获取数据时可以使用GET请求，需要提交数据时可以使用POST请求。


# PUT和POST都是给服务器发送新增资源，有什么区别？

PUT 和 POST 都可以用于向服务器发送数据并创建资源，但它们在语义和行为上存在一些关键区别。了解这些区别有助于正确选择使用哪种方法来实现特定的 API 行为。

### PUT 和 POST 的区别

1. **语义**：
   - **POST**：
     - 用于向服务器发送数据，通常用于创建新资源。
     - 是一种非幂等操作：多次发送相同的 POST 请求可能会创建多个资源。
     - 服务器会根据请求生成新的资源位置（URI）。

   - **PUT**：
     - 用于向服务器发送数据，通常用于创建或更新资源。
     - 是一种幂等操作：多次发送相同的 PUT 请求会产生相同的结果（创建或更新同一个资源）。
     - 客户端指定资源位置（URI），如果资源不存在，服务器会创建资源；如果资源存在，服务器会更新资源。

2. **资源位置**：
   - **POST**：
     - 客户端不知道资源的具体位置，服务器根据请求创建资源并返回其位置（通常通过 `Location` 头部）。

   - **PUT**：
     - 客户端知道资源的具体位置，直接在该位置创建或更新资源。

3. **幂等性**：
   - **POST**：
     - 非幂等：多次相同的 POST 请求会产生不同的结果（如创建多个资源）。

   - **PUT**：
     - 幂等：多次相同的 PUT 请求会产生相同的结果（如更新同一个资源，或者在同一个位置创建同一个资源）。

4. **数据更新**：
   - **POST**：
     - 通常用于创建新资源，不常用于更新资源。

   - **PUT**：
     - 可以用于创建新资源，但更常用于更新现有资源。

### 示例

**POST 请求示例**：

```http
POST /users HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Alice",
  "age": 30
}
```

- 服务器处理请求并创建新用户资源。
- 服务器返回新资源的位置。

**PUT 请求示例**：

```http
PUT /users/123 HTTP/1.1
Host: example.com
Content-Type: application/json

{
  "name": "Alice",
  "age": 30
}
```

- 如果资源 `/users/123` 存在，服务器会更新该资源。
- 如果资源 `/users/123` 不存在，服务器会创建新资源。

### 使用场景

- **POST**：
  - 创建新资源时使用，特别是在客户端不知道资源 URI 的情况下。
  - 适用于提交表单数据、上传文件等需要服务器生成资源 URI 的情况。

- **PUT**：
  - 创建或更新资源时使用，特别是在客户端知道资源 URI 的情况下。
  - 适用于需要保证幂等性的情况，例如更新用户信息、替换文件内容等。

### 总结

- **POST** 用于创建新资源，服务器决定新资源的 URI，操作非幂等。
- **PUT** 用于创建或更新资源，客户端提供资源的 URI，操作幂等。

理解这些区别有助于设计 RESTful API，确保 API 的行为符合预期，并提高应用程序的可维护性和一致性。


# 常见的Http请求头

HTTP 请求头是在发送 HTTP 请求时包含的元数据信息，它们提供了关于请求的各种信息，比如客户端、服务器、请求内容等。以下是一些常见的 HTTP 请求头：

1. **Host（主机）：**
   指定服务器的主机名和端口号，告诉服务器请求的目标地址。

2. **User-Agent（用户代理）：**
   包含了发送请求的用户代理应用程序的相关信息，比如浏览器类型、操作系统等。

3. **Accept（接受）：**
   告诉服务器可以接受的响应内容的类型，通常是 MIME 类型，比如 `text/html`、`application/json` 等。

4. **Accept-Language（接受语言）：**
   告诉服务器可以接受的响应内容的语言，用于国际化和多语言支持。

5. **Accept-Encoding（接受编码）：**
   告诉服务器可以接受的响应内容的压缩编码方式，比如 gzip、deflate 等。

6. **Connection（连接）：**
   控制是否使用持久连接（HTTP/1.1 默认使用持久连接），或者要求服务器关闭连接。

7. **Authorization（授权）：**
   包含了客户端认证信息，用于进行身份验证，比如 Basic Auth、Bearer Token 等。

8. **Referer（引用）：**
   表示当前请求是从哪个页面跳转过来的，用于统计分析和防盗链。

9. **Cookie（Cookie）：**
   包含了客户端发送给服务器的 Cookie 信息，用于会话管理和用户识别。

10. **Content-Type（内容类型）：**
    表示请求体的数据类型和编码格式，比如 `application/json`、`multipart/form-data` 等。

11. **Content-Length（内容长度）：**
    表示请求体的数据长度，用于服务器接收数据的边界判断。

12. **Cache-Control（缓存控制）：**
    控制缓存的行为，比如 `no-cache`、`max-age` 等，用于优化网络请求和节省带宽。

这些是常见的 HTTP 请求头，根据具体的应用场景和需求，可能会有更多的请求头信息。在实际开发中，根据需要添加或修改请求头，可以实现更灵活和精确的 HTTP 请求控制和管理。

# 聊⼀聊HTTP的状态码有哪些？

HTTP状态码是服务器在响应客户端请求时返回的一个三位数字的代码，用于表示服务器对请求的处理结果。状态码分为五类，每类都有不同的含义。以下是常见的HTTP状态码及其含义：

1. **1xx - 信息性状态码**：
   - 100 Continue：服务器已收到请求的头部，并且客户端应继续发送请求的主体部分。
   - 101 Switching Protocols：服务器正在切换协议，如切换到WebSocket协议。

2. **2xx - 成功状态码**：
   - 200 OK：请求成功。服务器成功返回请求的数据。
   - 201 Created：请求已经被实现，并且创建了新的资源。
   - 204 No Content：服务器成功处理了请求，但没有返回任何内容。

3. **3xx - 重定向状态码**：
   - 301 Moved Permanently：请求的资源已被永久移动到新位置。
   - 302 Found（或者临时重定向）：请求的资源暂时被移动到新位置。
   - 304 Not Modified：资源未被修改，可使用缓存的版本。

4. **4xx - 客户端错误状态码**：
   - 400 Bad Request：请求语法错误，服务器无法理解。
   - 401 Unauthorized：请求需要用户身份验证。
   - 403 Forbidden：服务器拒绝请求，权限不足。
   - 404 Not Found：请求的资源不存在。

5. **5xx - 服务器错误状态码**：
   - 500 Internal Server Error：服务器内部错误，无法完成请求。
   - 502 Bad Gateway：服务器作为网关或代理，从上游服务器接收到无效响应。
   - 503 Service Unavailable：服务器暂时无法处理请求，通常是因为过载或维护。

除了上述常见的状态码外，HTTP/1.1和HTTP/2还定义了其他一些状态码，如418 I'm a teapot（我是一个茶壶），是一个作为愚人节玩笑而定义的状态码。不同的状态码反映了不同的请求和响应情况，开发者可以根据状态码快速了解请求的处理结果，并作出相应的处理。

# HTTP的keep-alive是⼲什么的？

HTTP 的 `keep-alive` 机制，也称为持久连接（Persistent Connection），用于保持客户端和服务器之间的连接在多个请求/响应周期中持续打开，而不是在每个请求后立即关闭。其目的是提高网络效率，减少延迟和资源开销。

### `keep-alive` 的作用

1. **减少延迟**：在传统的非持久连接中，每个 HTTP 请求都需要重新建立 TCP 连接，而 `keep-alive` 允许复用现有的连接，从而避免了重复的连接建立和断开操作，减少了网络延迟。

2. **降低开销**：每次建立和关闭 TCP 连接都会消耗系统资源，如 CPU 和内存，通过复用连接可以减少这些资源的开销。

3. **提高效率**：对于需要发送多个请求的网页加载场景，持久连接可以显著提高数据传输效率，因为它消除了多次握手和连接管理的开销。

### 工作原理

在 HTTP/1.1 中，持久连接是默认启用的，只要没有显式关闭连接（例如，使用 `Connection: close` 头部）。以下是 `keep-alive` 的工作机制：

1. **请求头**：客户端在请求头中包含 `Connection: keep-alive`，表示希望服务器保持连接。
2. **响应头**：服务器在响应头中包含 `Connection: keep-alive`，表示同意保持连接。
3. **连接复用**：在这个连接上，客户端可以继续发送新的 HTTP 请求，而不需要重新建立连接。
4. **连接关闭**：连接在空闲一段时间后，服务器可以主动关闭连接，或者客户端可以在请求头中包含 `Connection: close`，指示服务器在完成响应后关闭连接。

### 示例

**请求头**：

```http
GET /index.html HTTP/1.1
Host: example.com
Connection: keep-alive
```

**响应头**：

```http
HTTP/1.1 200 OK
Content-Type: text/html
Connection: keep-alive
```

### 配置 `keep-alive` 选项

- **超时**：设置连接空闲的最大时间。例如，`Keep-Alive: timeout=5` 表示连接空闲超过 5 秒后将关闭。
- **最大请求数**：限制单个持久连接可以处理的最大请求数。例如，`Keep-Alive: max=100` 表示连接可以处理 100 个请求后关闭。

**示例**：

```http
Keep-Alive: timeout=5, max=100
```

### 优点与注意事项

**优点**：
- 减少了 TCP 连接的建立和拆除的开销。
- 提高了网络应用的响应速度。
- 有助于减少网络拥堵。

**注意事项**：
- 过多的持久连接可能会导致服务器资源耗尽，因此需要合理配置超时和最大请求数。
- 需要根据实际网络环境和应用需求调整配置，以平衡性能和资源利用。

### 总结

`keep-alive` 通过保持客户端和服务器之间的连接打开，实现了多个请求的复用，减少了连接建立和关闭的开销，提高了网络效率和应用性能。在实际应用中，合理配置 `keep-alive` 参数可以获得更好的性能表现。

# http请求报文、响应报文（TODO）


# HTTP2相对于HTTP1.x有什么优势和特点？(TODO)


# TCP、UDP、HTTP协议的区别与联系

TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）和HTTP（Hypertext Transfer Protocol）是计算机网络中常见的三种不同的协议，它们各自有不同的特点和用途。

### TCP（传输控制协议）

1. **特点：**
   - 面向连接：在数据传输前需要先建立连接，通过三次握手来确认连接的建立。
   - 可靠性：通过数据包的序号、确认和重传机制，保证数据的可靠性和完整性。
   - 有序性：保证数据包按照发送的顺序进行传输和接收。
   - 流量控制：通过滑动窗口等机制来控制数据的流量和传输速率。
   - 拥塞控制：根据网络情况调整传输速率，避免网络拥塞。
   - 面向字节流：数据以字节流的形式进行传输。

2. **应用场景：**
   - 适用于对数据可靠性要求较高、需要按顺序传输的应用，如文件传输、电子邮件、网页浏览等。

### UDP（用户数据报协议）

1. **特点：**
   - 无连接：发送数据前不需要建立连接，直接发送数据包。
   - 不可靠性：不保证数据的可靠性和完整性，可能丢失或乱序。
   - 无序性：数据包之间没有顺序要求。
   - 高效性：因为不需要建立连接和进行确认，传输效率高。

2. **应用场景：**
   - 适用于对实时性要求较高、数据量较小、能容忍少量数据丢失的应用，如音视频流传输、在线游戏、实时通信等。

### HTTP（超文本传输协议）

1. **特点：**
   - 应用层协议：位于 OSI 模型的应用层，用于传输超文本（HTML、CSS、JavaScript）和网页内容。
   - 无状态：每次请求和响应之间是独立的，服务器不会记录客户端的状态。
   - 基于请求-响应模式：客户端发送请求，服务器返回响应。
   - 文本协议：数据以文本形式传输，便于阅读和调试。

2. **应用场景：**
   - 用于在客户端和服务器之间传输网页内容、图片、视频等超文本数据。

### 区别与联系

- **TCP 和 UDP 的区别：** TCP 是面向连接的、可靠的、有序的传输协议，适用于数据可靠性要求较高的应用；UDP 是无连接的、不可靠的、无序的传输协议，适用于实时性要求较高的应用。
  
- **TCP 和 UDP 的联系：** TCP 和 UDP 都是传输层协议，它们共同负责在网络中传输数据。TCP 和 UDP 都使用端口号来区分不同的应用程序或服务，并且都支持多路复用和多路分解的功能。

- **TCP 和 HTTP 的区别：** TCP 是传输层协议，负责数据的可靠传输；HTTP 是应用层协议，负责超文本数据的传输。HTTP 使用 TCP 协议来传输数据，建立在 TCP 的基础之上。

- **UDP 和 HTTP 的区别：** UDP 是传输层协议，用于快速传输实时数据；HTTP 是应用层协议，用于传输超文本数据。HTTP 使用 TCP 协议来传输数据，可靠性较高，适合传输网页等数据。


